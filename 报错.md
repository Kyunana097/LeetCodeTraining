### 1047 约瑟夫环

源代码与报错
```
====================[ 构建 | 1047_JosephusRing | Debug ]==========================
"D:\CLion 2025.2.1\bin\cmake\win\x64\bin\cmake.exe" --build D:\code\LeetCode\cmake-build-debug --target 1047_JosephusRing
[ 50%] Building CXX object CMakeFiles/1047_JosephusRing.dir/src/1047_JosephusRing.cpp.obj
1047_JosephusRing.cpp
?⒁? 包含文件:           C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\typeinfo
D:\code\LeetCode\src\1047_JosephusRing.cpp(8): error C2131: 表达式的计算结果不是常数
D:\code\LeetCode\src\1047_JosephusRing.cpp(8): note: 因读取超过生命周期的变量而失败
D:\code\LeetCode\src\1047_JosephusRing.cpp(8): note: 请参见“n”的用法
D:\code\LeetCode\src\1047_JosephusRing.cpp(14): error C3863: 不可指定数组类型“bool [n]”
D:\code\LeetCode\src\1047_JosephusRing.cpp(19): error C2065: “i”: 未声明的标识符
D:\code\LeetCode\src\1047_JosephusRing.cpp(20): error C2065: “i”: 未声明的标识符
NMAKE : fatal error U1077: ��"D:\CLion 2025.2.1\bin\cmake\win\x64\bin\cmake.exe" -E cmake_cl_compile_depends --dep-file=CMakeFiles\1047_JosephusRing.dir\src\1047_JosephusRing.cpp.obj.d --working-dir=D:\code\LeetCode\cmake-build-debug --filter-prefix="ע��: �����ļ�:  " -- C:\PROGRA~1\MICROS~2\2022\COMMUN~1\VC\Tools\MSVC\1441~1.341\bin\Hostx64\x64\cl.exe @C:\Users\62705\AppData\Local\Temp\nm306B.tmp��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\1047_JosephusRing.dir\build.make /nologo -SL                 CMakeFiles\1047_JosephusRing.dir\build��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\Makefile2 /nologo -SL                 CMakeFiles\1047_JosephusRing.dir\all��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\Makefile2 /nologo -LS                 1047_JosephusRing��: ���ش��롰0x2��
Stop.

#include <iostream>
using namespace std;

int main() {
    int n,cnt = 0 , last;
    cin >> n;
    int survivor = n;
    bool alive[n] = {true};
    while (survivor) {
        for (int i = 0; i < n; i++) {
            if (alive[i])
                cnt++;
            if (cnt == 3) {
                alive[i] = false;
                cnt = 0;
                survivor--;
            }
        }
        if (i == n)
            i = 0;
    }
    for (int i = 0; i < n; i++) {
        if (alive[i])
            cout << i << endl;
    }
    return 0;
}
//
// Created by 62705 on 2025/10/6.
//
```

**MSVC 不允许“变长数组”**（`bool alive[n]`），也不允许在 `for (int i...)` 之后继续用 `i`。
把数组改成 `std::vector<bool>`（或 `new bool[n]`），再把回绕逻辑写对即可

### 1128 排序问题（1）

源代码

```
#include <iostream>
#include  <algorithm>

int main() {
    int arr[4];
    for (int & i : arr) {
        std::cin >> i;
    }
    std::sort(arr,arr+3);
    for (int & i : arr) {
        std::cout << arr[i];
    }
    std::cout << endl;
    return 0;
}
```

1. 排序范围写错
	`std::sort(arr, arr+3);` 只排前 3 个元素，**第 4 个数被漏掉**。
	应改为 `std::sort(arr, arr+4);` 或 `std::begin(arr), std::end(arr)`。
2. 输出语句逻辑错
	`std::cout << arr[i];` 把元素值 `i` 当成下标，结果打印的是 `arr[0]~arr[3]` 之外的**随机内存**，属于 **越界访问**。
	应改为 `std::cout << i;`（因为范围 for 里 `i` 就是元素本身）。
3. 缺少 `std::` 前缀
	`endl` 没写 `std::`，会编译错误（你用了 `<iostream>` 但没 `using namespace std;`）。

### 1023 选择排序

源代码

```
#include <iostream>
#include <algorithm>

void SelectionSort(int a[],int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minPos = i;
        for (int j = 0; j < n; ++j) {
            if (a[j] < a[i])
                minPos = j;
        }
        if (minPos!=i)
            std::swap(a[i],a[minPos]);
    }
}

int main() {
    int array[10];
    for (int & x : array)
        std::cin >> x;
    SelectionSort(array,10);
    for (int & i : array)
        std::cout << i << std::endl;
    return 0;
}
//
// Created by 62705 on 2025/10/6.
//
```

问题出在 **内层循环的起始值和比较对象**写错了，导致：

- 每次把**整个数组最小值**换到前面，而不是**未排序段的最小值**；
- 相等元素相对顺序被反复打乱 → **不稳定**；
- 还把已经排好的区间又扫一遍，效率从 O(n²) 退到“看起来对，其实乱”。

第二次修改

```
void SelectionSort(int a[],int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minPos = i;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[i])
                minPos = j;
        }
        if (minPos!=i)
            std::swap(a[i],a[minPos]);
    }
}
```

内层循环中使用a[j] < a[i]，导致当minPos改变时 仍是对a[i]进行比较