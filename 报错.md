### 1047 约瑟夫环

源代码与报错
```
====================[ 构建 | 1047_JosephusRing | Debug ]==========================
"D:\CLion 2025.2.1\bin\cmake\win\x64\bin\cmake.exe" --build D:\code\LeetCode\cmake-build-debug --target 1047_JosephusRing
[ 50%] Building CXX object CMakeFiles/1047_JosephusRing.dir/src/1047_JosephusRing.cpp.obj
1047_JosephusRing.cpp
?⒁? 包含文件:           C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\typeinfo
D:\code\LeetCode\src\1047_JosephusRing.cpp(8): error C2131: 表达式的计算结果不是常数
D:\code\LeetCode\src\1047_JosephusRing.cpp(8): note: 因读取超过生命周期的变量而失败
D:\code\LeetCode\src\1047_JosephusRing.cpp(8): note: 请参见“n”的用法
D:\code\LeetCode\src\1047_JosephusRing.cpp(14): error C3863: 不可指定数组类型“bool [n]”
D:\code\LeetCode\src\1047_JosephusRing.cpp(19): error C2065: “i”: 未声明的标识符
D:\code\LeetCode\src\1047_JosephusRing.cpp(20): error C2065: “i”: 未声明的标识符
NMAKE : fatal error U1077: ��"D:\CLion 2025.2.1\bin\cmake\win\x64\bin\cmake.exe" -E cmake_cl_compile_depends --dep-file=CMakeFiles\1047_JosephusRing.dir\src\1047_JosephusRing.cpp.obj.d --working-dir=D:\code\LeetCode\cmake-build-debug --filter-prefix="ע��: �����ļ�:  " -- C:\PROGRA~1\MICROS~2\2022\COMMUN~1\VC\Tools\MSVC\1441~1.341\bin\Hostx64\x64\cl.exe @C:\Users\62705\AppData\Local\Temp\nm306B.tmp��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\1047_JosephusRing.dir\build.make /nologo -SL                 CMakeFiles\1047_JosephusRing.dir\build��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\Makefile2 /nologo -SL                 CMakeFiles\1047_JosephusRing.dir\all��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\Makefile2 /nologo -LS                 1047_JosephusRing��: ���ش��롰0x2��
Stop.

#include <iostream>
using namespace std;

int main() {
    int n,cnt = 0 , last;
    cin >> n;
    int survivor = n;
    bool alive[n] = {true};
    while (survivor) {
        for (int i = 0; i < n; i++) {
            if (alive[i])
                cnt++;
            if (cnt == 3) {
                alive[i] = false;
                cnt = 0;
                survivor--;
            }
        }
        if (i == n)
            i = 0;
    }
    for (int i = 0; i < n; i++) {
        if (alive[i])
            cout << i << endl;
    }
    return 0;
}
//
// Created by 62705 on 2025/10/6.
//
```

**MSVC 不允许“变长数组”**（`bool alive[n]`），也不允许在 `for (int i...)` 之后继续用 `i`。
把数组改成 `std::vector<bool>`（或 `new bool[n]`），再把回绕逻辑写对即可

### 1128 排序问题（1）

源代码

```
#include <iostream>
#include  <algorithm>

int main() {
    int arr[4];
    for (int & i : arr) {
        std::cin >> i;
    }
    std::sort(arr,arr+3);
    for (int & i : arr) {
        std::cout << arr[i];
    }
    std::cout << endl;
    return 0;
}
```

1. 排序范围写错
	`std::sort(arr, arr+3);` 只排前 3 个元素，**第 4 个数被漏掉**。
	应改为 `std::sort(arr, arr+4);` 或 `std::begin(arr), std::end(arr)`。
2. 输出语句逻辑错
	`std::cout << arr[i];` 把元素值 `i` 当成下标，结果打印的是 `arr[0]~arr[3]` 之外的**随机内存**，属于 **越界访问**。
	应改为 `std::cout << i;`（因为范围 for 里 `i` 就是元素本身）。
3. 缺少 `std::` 前缀
	`endl` 没写 `std::`，会编译错误（你用了 `<iostream>` 但没 `using namespace std;`）。

### 1023 选择排序

源代码

```
#include <iostream>
#include <algorithm>

void SelectionSort(int a[],int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minPos = i;
        for (int j = 0; j < n; ++j) {
            if (a[j] < a[i])
                minPos = j;
        }
        if (minPos!=i)
            std::swap(a[i],a[minPos]);
    }
}

int main() {
    int array[10];
    for (int & x : array)
        std::cin >> x;
    SelectionSort(array,10);
    for (int & i : array)
        std::cout << i << std::endl;
    return 0;
}
//
// Created by 62705 on 2025/10/6.
//
```

问题出在 **内层循环的起始值和比较对象**写错了，导致：

- 每次把**整个数组最小值**换到前面，而不是**未排序段的最小值**；
- 相等元素相对顺序被反复打乱 → **不稳定**；
- 还把已经排好的区间又扫一遍，效率从 O(n²) 退到“看起来对，其实乱”。

第二次修改

```
void SelectionSort(int a[],int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minPos = i;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[i])
                minPos = j;
        }
        if (minPos!=i)
            std::swap(a[i],a[minPos]);
    }
}
```

内层循环中使用a[j] < a[i]，导致当minPos改变时 仍是对a[i]进行比较

### 1044 字符串排序

源代码

```
#include <iostream>
#include <algorithm>

int main() {
    std::string s[3];
    for (std::string & x : s)
        std::getline(std::cin,x);
    std::sort(std::begin(s),std::end(s));
    for (const std::string & x : s)
        std::cout << x << "\n";
    return 0;
}
```

`getline`报错 显示不在`std`中

- 忘记`include <string>`

### 1739 学生成绩排序

源代码

```
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>

typedef struct Student {
    std::string name;
    int age;
    double score;
}Student;

int main() {
    int n;
    while (std::cin >> n) {
        std::vector<Student> stu(n);
        for (int i = 0; i < n; ++i)
            std::cin >> stu[i].name >> stu[i].age >> stu[i].score;
        std::sort(std::begin(),std::end()，
            [](const Student &a, const Student &b) {
                if (a.score != b.score)
                    return a.score < b.score;
                if (a.name != b.name)
                    return a.name < b.name;
                return a.age < b.age;
            })
    }
    for (int i = 0; i < n; ++i)
        std::cout << stu[i].name << stu[i].age << stu[i].score << "\n";
    return 0;
}
====================[ 构建 | 1739_ScoreArrange | Debug ]==========================
"D:\CLion 2025.2.1\bin\cmake\win\x64\bin\cmake.exe" --build D:\code\LeetCode\cmake-build-debug --target 1739_ScoreArrange
[ 50%] Building CXX object CMakeFiles/1739_ScoreArrange.dir/src/1739_ScoreArrange.cpp.obj
1739_ScoreArrange.cpp
D:\code\LeetCode\src\1739_ScoreArrange.cpp(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): error C2672: “std::begin”: 未找到匹配的重载函数
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility(1962): note: 可能是“_Ty *std::begin(_Ty (&)[_Size]) noexcept”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “_Ty *std::begin(_Ty (&)[_Size]) noexcept”: 应输入 1 个参数，却提供了 0 个
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility(1944): note: 或    “unknown-type std::begin(const _Container &) noexcept(<expr>)”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “unknown-type std::begin(const _Container &) noexcept(<expr>)”: 应输入 1 个参数，却提供了 0 个
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility(1938): note: 或    “unknown-type std::begin(_Container &) noexcept(<expr>)”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “unknown-type std::begin(_Container &) noexcept(<expr>)”: 应输入 1 个参数，却提供了 0 个
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\initializer_list(54): note: 或    “const _Elem *std::begin(std::initializer_list<_Elem>) noexcept”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “const _Elem *std::begin(std::initializer_list<_Elem>) noexcept”: 应输入 1 个参数，却提供了 0 个
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): error C2672: “std::end”: 未找到匹配的重载函数
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility(1967): note: 可能是“_Ty *std::end(_Ty (&)[_Size]) noexcept”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “_Ty *std::end(_Ty (&)[_Size]) noexcept”: 应输入 1 个参数，却提供了 0 个
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility(1956): note: 或    “unknown-type std::end(const _Container &) noexcept(<expr>)”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “unknown-type std::end(const _Container &) noexcept(<expr>)”: 应输入 1 个参数，却提供了 0 个
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility(1950): note: 或    “unknown-type std::end(_Container &) noexcept(<expr>)”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “unknown-type std::end(_Container &) noexcept(<expr>)”: 应输入 1 个参数，却提供了 0 个
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\initializer_list(59): note: 或    “const _Elem *std::end(std::initializer_list<_Elem>) noexcept”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “const _Elem *std::end(std::initializer_list<_Elem>) noexcept”: 应输入 1 个参数，却提供了 0 个
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): error C2146: 语法错误: 缺少“)”(在标识符“锛”的前面)
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): error C2672: “std::sort”: 未找到匹配的重载函数
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\algorithm(8401): note: 可能是“void std::sort(_ExPo &&,const _RanIt,const _RanIt) noexcept”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “void std::sort(_ExPo &&,const _RanIt,const _RanIt) noexcept”: 应输入 3 个参数，却提供了 1 个
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\algorithm(8398): note: 或    “void std::sort(_ExPo &&,_RanIt,_RanIt,_Pr) noexcept”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “void std::sort(_ExPo &&,_RanIt,_RanIt,_Pr) noexcept”: 应输入 4 个参数，却提供了 1 个
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\algorithm(8392): note: 或    “void std::sort(const _RanIt,const _RanIt)”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “void std::sort(const _RanIt,const _RanIt)”: 应输入 2 个参数，却提供了 1 个
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\algorithm(8384): note: 或    “void std::sort(const _RanIt,const _RanIt,_Pr)”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): note: “void std::sort(const _RanIt,const _RanIt,_Pr)”: 应输入 3 个参数，却提供了 1 个
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): error C2146: 语法错误: 缺少“;”(在标识符“锛”的前面)
D:\code\LeetCode\src\1739_ScoreArrange.cpp(18): error C2065: “锛”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(19): error C2059: 语法错误:“]”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(19): error C2143: 语法错误: 缺少“;”(在“{”的前面)
D:\code\LeetCode\src\1739_ScoreArrange.cpp(20): error C2065: “a”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(20): error C2065: “b”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(21): error C2065: “a”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(21): error C2065: “b”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(22): error C2065: “a”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(22): error C2065: “b”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(23): error C2065: “a”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(23): error C2065: “b”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(24): error C2065: “a”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(24): error C2065: “b”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(25): error C2059: 语法错误:“)”
D:\code\LeetCode\src\1739_ScoreArrange.cpp(28): error C2065: “stu”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(28): error C2065: “stu”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(28): error C2065: “stu”: 未声明的标识符
NMAKE : fatal error U1077: ��"D:\CLion 2025.2.1\bin\cmake\win\x64\bin\cmake.exe" -E cmake_cl_compile_depends --dep-file=CMakeFiles\1739_ScoreArrange.dir\src\1739_ScoreArrange.cpp.obj.d --working-dir=D:\code\LeetCode\cmake-build-debug --filter-prefix="ע��: �����ļ�:  " -- C:\PROGRA~1\MICROS~2\2022\COMMUN~1\VC\Tools\MSVC\1441~1.341\bin\Hostx64\x64\cl.exe @C:\Users\62705\AppData\Local\Temp\nm5076.tmp��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\1739_ScoreArrange.dir\build.make /nologo -SL                 CMakeFiles\1739_ScoreArrange.dir\build��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\Makefile2 /nologo -SL                 CMakeFiles\1739_ScoreArrange.dir\all��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\Makefile2 /nologo -LS                 1739_ScoreArrange��: ���ش��롰0x2��
Stop.
```

报错总结：

1. `std::begin()` / `std::end()` 没给实参
2. 中文全角逗号 `，` 混进代码
3. 作用域括号弄丢，导致 lambda 和变量都找不到

```
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>

struct Student {
    std::string name;
    int age;
    double score;
};

int main() {
    int n;
    while (std::cin >> n) {
        std::vector<Student> stu(n);
        for (int i = 0; i < n; ++i)
            std::cin >> stu[i].name >> stu[i].age >> stu[i].score;

        std::sort(stu.begin(),stu.end(),
            [](const Student &a, const Student &b) {
                if (a.score != b.score)
                    return a.score < b.score;
                if (a.name != b.name)
                    return a.name < b.name;
                return a.age < b.age;
            });
    }
    for (int i = 0; i < n; ++i)
        std::cout << stu[i].name << stu[i].age << stu[i].score << "\n";
    return 0;
}
//
// Created by 62705 on 2025/10/7.
//
====================[ 构建 | 1739_ScoreArrange | Debug ]==========================
"D:\CLion 2025.2.1\bin\cmake\win\x64\bin\cmake.exe" --build D:\code\LeetCode\cmake-build-debug --target 1739_ScoreArrange
[ 50%] Building CXX object CMakeFiles/1739_ScoreArrange.dir/src/1739_ScoreArrange.cpp.obj
1739_ScoreArrange.cpp
D:\code\LeetCode\src\1739_ScoreArrange.cpp(29): error C2065: “stu”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(29): error C2065: “stu”: 未声明的标识符
D:\code\LeetCode\src\1739_ScoreArrange.cpp(29): error C2065: “stu”: 未声明的标识符
NMAKE : fatal error U1077: ��"D:\CLion 2025.2.1\bin\cmake\win\x64\bin\cmake.exe" -E cmake_cl_compile_depends --dep-file=CMakeFiles\1739_ScoreArrange.dir\src\1739_ScoreArrange.cpp.obj.d --working-dir=D:\code\LeetCode\cmake-build-debug --filter-prefix="ע��: �����ļ�:  " -- C:\PROGRA~1\MICROS~2\2022\COMMUN~1\VC\Tools\MSVC\1441~1.341\bin\Hostx64\x64\cl.exe @C:\Users\62705\AppData\Local\Temp\nm2153.tmp��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\1739_ScoreArrange.dir\build.make /nologo -SL                 CMakeFiles\1739_ScoreArrange.dir\build��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\Makefile2 /nologo -SL                 CMakeFiles\1739_ScoreArrange.dir\all��: ���ش��롰0x2��
Stop.
NMAKE : fatal error U1077: ��"C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\bin\HostX64\x64\nmake.exe" -s -f CMakeFiles\Makefile2 /nologo -LS                 1739_ScoreArrange��: ���ش��롰0x2��
Stop.
```

问题：
`stu` 定义在 `while` 循环里，**出了循环就销毁**，后面那句 `for (int i = 0; i < n; ++i) …` 已经不在 `while` 作用域内，编译器找不到 `stu`，于是报 `error C2065: “stu”: 未声明的标识符`。

修正：把输出语句**挪进 while 内部**，紧跟排序后。

### 2214 递归快速排序

> 本次代码思路大部分使用AI帮助 需要仔细消化理解

源代码

```
#include <iostream>
#include <algorithm>
#include <vector>

//被调用的逻辑函数
int partition(std::vector<int>& vec, int low, int high) {
    int pivot = vec[high];  //选末位作为基准
    int i = low - 1;        //i是小于基准位的最后一个元素

    for(int j = low; j < high; j++){
        if(vec[j] < pivot){
            i++;
            std::swap(vec[i],vec[j]);
        }
    }
    std::swap(vec[high],vec[i+1]);
    return i+1;
}

//分治法分类函数
void Quick_Sort(std::vector<int>& vec, int low, int high) {
    if(low < high){
        int pi = partition(vec, low, high);
        //调用自身进行递归 直到子数组大小为0或1
        Quick_Sort(vec, low, pi - 1);
        Quick_Sort(vec, pi + 1, high);
    }
}

int main() {
    int x;
    std::vector<int> vec;
    while (std::cin >> x && x != 0)
        vec.push_back(x);

    Quick_Sort(vec, 0, vec.size() - 1);

    for(const int num : vec)
        std::cout << num << " ";

    std::cout << std::endl;
    return 0;
}
//
// Created by 62705 on 2025/10/7.
//
```

问题点：

- 将调用函数的代码段放在被调用函数的前面，导致编译器找不到调用函数
- 使用    while (!(std::cin >> x))来传入数据 而忽视题干中的输入0时终止
  - 解决：改用while (std::cin >> x && x != 0) 

### 1716 非递归快速排序

> 由递归快速排序修改得到，通过自己操纵栈来模拟递归在栈中的操作

源代码

```
#include <iostream>
#include <vector>

//被调用的逻辑函数
int partition(std::vector<int>& vec, int low, int high) {
	//逻辑一样
}

void QuickSort(std::vector<int>& vec, int low, int high) {
    std::vector<std::pair<int, int>> stack;
    stack.emplace_back(low, high);

    while(!stack.empty()){
        auto [l, h] = stack.back();
        stack.pop_back();

        if(l < h){
            int pi = partition(vec, l, h);

            //先压大再压小
            if(pi + 1 < h)
                stack.emplace_back(pi + 1, h);
            if(l < pi - 1)
                stack.emplace_back(l, pi - 1);
        }
    }
}

int main() {、
	//逻辑yi
}
//
// Created by 62705 on 2025/10/9.
//
```



### 1714 直接插入排序

源代码

```
#include <iostream>
#include <vector>
#include <algorithm>

int main(){
    int Num;
    std::vector<int> vec;
    std::cin >> Num;
    if(Num <= 0)
        return -1;
    int x;
    for(int i = 0; i < Num; i++){
        std::cin >> x;
        vec.push_back(x);
    }

    std::sort(vec.begin(), vec.end());

    for(const int &i : vec)
        std::cout << vec[i] << " ";
    std::cout << std::endl;
    return 0;
}
```

在输出排序后的数组时，您使用了 `vec[i]` 而不是 `i`。在范围基 `for` 循环中，`i` 是数组中的当前元素，而不是索引

若使用vec[i]，则相当于把当前vec[i]的值给vec 让vec去找这个下标vec[vec[i]]的值

改为直接插入排序方法：

    // 直接插入排序
    for (int i = 1; i < n; ++i) {
        int key = vec[i];
        int j = i - 1;
        
        // 将 vec[i] 插入到已排序序列 vec[0...i-1] 中的正确位置
        while (j >= 0 && vec[j] > key) {
            vec[j + 1] = vec[j];
            --j;
        }
        vec[j + 1] = key;
    }

### 1717 简单选择排序

源代码

```
#include <iostream>
#include <vector>

int Select_Min_Key(std::vector<int>& vec,int i) {
    int Key = vec[i];
    for (int & j : vec) {
        if (Key > j)
            Key = j;
    }
    return Key;
}

void Select_Sort(std::vector<int>& vec) {
    for (int i = 1; i < vec.size(); ++i) {
        int j = Select_Min_Key(vec, i);
        if (i != j)
            std::swap(vec[i], vec[j]);
    }
}

int main() {
    int Num;
    std::cin >> Num;
    if(Num <= 0)
        return -1;
    int x;
    std::vector<int> vec;
    for(int i = 0; i < Num; i++){
        std::cin >> x;
        vec.push_back(x);
    }

    Select_Sort(vec);

    for(const int num : vec)
        std::cout << num << " ";

    std::cout << std::endl;
    return 0;
}

//
// Created by 62705 on 2025/10/10.
//
```

#### ❌ 问题 1：Select_Min_Key 根本没从 i 开始找

```cpp
for (int & j : vec)   // 遍历整个 vector，而不是 [i, end)
```

导致每次返回的都是**整个数组的最小值**，而不是**未排序段的最小值**。

------

#### ❌ 问题 2：Select_Min_Key 返回的是“值”，却当成“下标”用

```cpp
int j = Select_Min_Key(vec, i);  // j 是最小值
if (i != j)                      // 拿值当下标，逻辑错乱
```

#### ✅ 修正方案（最小改动）

把 `Select_Min_Key` 改成**返回最小元素的下标**，并且只扫 `[i, end)`：

```cpp
int Select_Min_Key(std::vector<int>& vec, int i) {
    int min_idx = i;
    for (int j = i + 1; j < vec.size(); ++j)
        if (vec[j] < vec[min_idx])
            min_idx = j;
    return min_idx;   // 返回下标
}
```

然后排序函数里用下标交换：

```cpp
void Select_Sort(std::vector<int>& vec) {
    for (int i = 0; i < vec.size(); ++i) {   // 从 0 开始
        int j = Select_Min_Key(vec, i);
        if (i != j) std::swap(vec[i], vec[j]);
    }
}
```

### 0001 两数之和
#### 源代码
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int>map;

        for(int i = 0; i < nums.size(); i++){
            int complement = target - nums[i];
            if(map.find(complement) != map.end()){
                return {map[complement], i};
            }
            map[nums[i]] = i;
        }
        return {};
    }
};
```
#### 问题
1. if (map.find(complement) != map.end())是什么
    - map.find(complement)：在哈希表里查 complement 这个键
    - 如果找到了 → 返回指向该键值对的迭代器
    - 如果没找到 → 返回 map.end()（一个特殊标记，表示"末尾之后"）
2. map[nums[i]] = i; 是什么
    - map 就是记录"我之前见过什么数，它们在哪"
    - 第一次计算时，因为没见过补数，所以不会返回结果，但会把第一个数记录，当计算补数时就会发现第一个数可用
    - 先查后存可以防止将一个数返回两次[n,n] (target = 2n时可能）